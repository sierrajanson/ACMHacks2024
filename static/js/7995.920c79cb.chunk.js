"use strict";(self.webpackChunkbox=self.webpackChunkbox||[]).push([[7995],{20176:(e,t,s)=>{s.d(t,{N3:()=>r,Om:()=>h});var i=s(1484);class h{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},s=arguments.length>2?arguments[2]:void 0,i=arguments.length>3?arguments[3]:void 0;this.geometry=e,this.attributes=t,this.centroid=s,this.objectId=i,this.displayId=0,this.geohashX=0,this.geohashY=0}static fromJSON(e,t){const s=e.geometry?i.A.fromJSON(e.geometry):null,r=e.centroid?i.A.fromJSON(e.centroid):null,o=e.attributes[t];return new h(s,e.attributes,r,o)}weakClone(){const e=new h(this.geometry,this.attributes,this.centroid,this.objectId);return e.displayId=this.displayId,e.geohashX=this.geohashX,e.geohashY=this.geohashY,e}clone(){const e=this.geometry?.clone(),t=new h(e,{...this.attributes},this.centroid?.clone(),this.objectId);return t.displayId=this.displayId,t.geohashX=this.geohashX,t.geohashY=this.geohashY,t}}function r(e){return!!e.geometry?.coords?.length}},75146:(e,t,s)=>{s.d(t,{A:()=>i});class i{constructor(){this.objectIdFieldName=null,this.globalIdFieldName=null,this.geohashFieldName=null,this.geometryProperties=null,this.geometryType=null,this.spatialReference=null,this.hasZ=!1,this.hasM=!1,this.features=[],this.fields=[],this.transform=null,this.exceededTransferLimit=!1,this.uniqueIdField=null,this.queryGeometryType=null,this.queryGeometry=null}weakClone(){const e=new i;return e.objectIdFieldName=this.objectIdFieldName,e.globalIdFieldName=this.globalIdFieldName,e.geohashFieldName=this.geohashFieldName,e.geometryProperties=this.geometryProperties,e.geometryType=this.geometryType,e.spatialReference=this.spatialReference,e.hasZ=this.hasZ,e.hasM=this.hasM,e.features=this.features,e.fields=this.fields,e.transform=this.transform,e.exceededTransferLimit=this.exceededTransferLimit,e.uniqueIdField=this.uniqueIdField,e.queryGeometry=this.queryGeometry,e.queryGeometryType=this.queryGeometryType,e}}},1484:(e,t,s)=>{s.d(t,{A:()=>i});class i{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.lengths=e??[],this.coords=t??[],this.hasIndeterminateRingOrder=s}static fromJSON(e){return new i(e.lengths,e.coords,e.hasIndeterminateRingOrder)}static fromRect(e){const[t,s,h,r]=e,o=h-t,n=r-s;return new i([5],[t,s,o,0,0,n,-o,0,0,-n])}get isPoint(){return 0===this.lengths.length}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce(((e,t)=>e+t))}forEachVertex(e){let t=0;this.lengths.length||e(this.coords[0],this.coords[1]);for(let s=0;s<this.lengths.length;s++){const i=this.lengths[s];for(let s=0;s<i;s++)e(this.coords[2*(s+t)],this.coords[2*(s+t)+1]);t+=i}}deltaDecode(){const e=this.clone(),{coords:t,lengths:s}=e;let i=0;for(const h of s){for(let e=1;e<h;e++)t[2*(i+e)]+=t[2*(i+e)-2],t[2*(i+e)+1]+=t[2*(i+e)-1];i+=h}return e}clone(e){if(0===this.lengths.length)return new i([],[this.coords[0],this.coords[1]]);const t=2*(0===this.lengths.length?1:this.lengths.reduce(((e,t)=>e+t))),s=this.coords.slice(0,t);return e?(e.set(s),new i(this.lengths,e,this.hasIndeterminateRingOrder)):new i(Array.from(this.lengths),Array.from(s),this.hasIndeterminateRingOrder)}}}}]);
//# sourceMappingURL=7995.920c79cb.chunk.js.map